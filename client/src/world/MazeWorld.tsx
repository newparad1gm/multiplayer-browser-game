/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.0.9 collision-world.glb
*/

import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { useLoader } from '@react-three/fiber';
import { World } from './World';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader';

interface WorldProps {
    world: World;
	startGame: () => void;
	divRef: React.RefObject<HTMLDivElement>;
}

export const MazeWorld = (props: WorldProps): JSX.Element => {
	const { world, startGame, divRef } = props;
	const background = useLoader(RGBELoader, '/textures/royal_esplanade_1k.hdr');
	const sceneRef = useRef<THREE.Scene>(null);
	const floorTexture = useLoader(THREE.TextureLoader, '/textures/pexels-hoang-le-978462.jpg');
	const wallTexture = useLoader(THREE.TextureLoader, '/textures/pexels-pixabay-220182.jpg');
	const grassTexture = useLoader(THREE.TextureLoader, '/textures/pexels-colys-hat-1587548.jpg');
	const woodTexture = useLoader(THREE.TextureLoader, '/textures/pexels-wood-3750272.jpg');

    useEffect(() => {
		background.mapping = THREE.EquirectangularReflectionMapping;
		world.background = background;
		world.environment = background;
		world.fog = new THREE.Fog(0x88ccee, 0, 50);

		const fillLight = new THREE.HemisphereLight(0x4488bb, 0x002244, 0.5);
		fillLight.position.set(2, 1, 1);
		world.lights.push(fillLight);

		const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
		directionalLight.position.set(-5, 25, -1);
		directionalLight.castShadow = true;
		directionalLight.shadow.camera.near = 0.01;
		directionalLight.shadow.camera.far = 500;
		directionalLight.shadow.camera.right = 30;
		directionalLight.shadow.camera.left = -30;
		directionalLight.shadow.camera.top	= 30;
		directionalLight.shadow.camera.bottom = -30;
		directionalLight.shadow.mapSize.width = 1024;
		directionalLight.shadow.mapSize.height = 1024;
		directionalLight.shadow.radius = 4;
		directionalLight.shadow.bias = -0.00006;
		world.lights.push(directionalLight);

		startGame();
    }, [background, startGame, world]);

	useEffect(() => {
		const currMeshes: THREE.Object3D<THREE.Event>[] = [];
		const maze = world.maze;

		grassTexture.encoding = THREE.sRGBEncoding;
		const grassMat = new THREE.MeshLambertMaterial({ map: grassTexture });
		const grassArea = new THREE.Vector2(maze.rows + 20, 75);
		const grassAreaFloor = new THREE.Mesh(new THREE.BoxGeometry(grassArea.x, 0.02, grassArea.y), grassMat);
		grassAreaFloor.position.set((grassArea.x / 2) - 10, -0.05, 0);
		grassAreaFloor.castShadow = true;
		grassAreaFloor.receiveShadow = true;
		currMeshes.push(grassAreaFloor);

		woodTexture.encoding = THREE.sRGBEncoding;
		const woodMat = new THREE.MeshLambertMaterial({ map: woodTexture });
		const width = (grassArea.y / 2) - (maze.cols / 2);
		const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1, maze.wallHeight, width), woodMat);
		leftWall.position.set(0, maze.wallHeight / 2, -(grassArea.y / 4) - (maze.cols / 4) );
		leftWall.castShadow = true;
		leftWall.receiveShadow = true;
		currMeshes.push(leftWall);
		const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1, maze.wallHeight, width + 1), woodMat);
		rightWall.position.set(0, maze.wallHeight / 2, (grassArea.y / 4) + (maze.cols / 4) - 1);
		rightWall.castShadow = true;
		rightWall.receiveShadow = true;
		currMeshes.push(rightWall);

		floorTexture.encoding = THREE.sRGBEncoding;
		const floorMat = new THREE.MeshLambertMaterial({ map: floorTexture });
		const mazeFloor = new THREE.Mesh(new THREE.BoxGeometry(maze.rows - 1, 0.02, maze.cols - 1), floorMat);
		mazeFloor.position.set((maze.rows / 2) - 0.5, 0, -0.5);
		mazeFloor.castShadow = true;
		mazeFloor.receiveShadow = true;
		currMeshes.push(mazeFloor);

		wallTexture.encoding = THREE.sRGBEncoding;
		wallTexture.wrapS = THREE.RepeatWrapping;
		wallTexture.wrapT = THREE.RepeatWrapping;
		wallTexture.repeat.x = .5;
		wallTexture.repeat.y = maze.wallHeight / 2;
		const mazeMat = new THREE.MeshLambertMaterial({ map: wallTexture });
		const mazeMesh = maze.generateMazeMesh(mazeMat);
		mazeMesh.castShadow = true;
		mazeMesh.receiveShadow = true;
		mazeMesh.position.set(0, 0, -(maze.cols / 2));
		currMeshes.push(mazeMesh);

		if (divRef.current) {
			const screen = world.addScreen(divRef.current);
			if (screen) {
				currMeshes.push(screen);
			}
		}

		for (const newMesh of currMeshes) {
			world.worldScene.add(newMesh);
		}
		
		world.octree.fromGraphNode(world.worldScene);
	}, [floorTexture, wallTexture, grassTexture, woodTexture, world, divRef]);

	useEffect(() => {
		if (sceneRef.current) {
			sceneRef.current.add(world.worldScene);
		}
	}, [sceneRef, world]);

	return (
		<group {...props} dispose={null}>
			<scene ref={sceneRef}/>
		</group>
	)
}